# SSL Implementation
## Introduction
S/SL is a compiler generation tool - so not surprisingly, it is implemented in much the same way as a compiler.

SSL is compiled (by a program written in SSL!) to a compact byte code, which can be interpreted by and only by an SSL abstract machine.

The SSL abstract machine is like a byte code virtual machine. It is a machine because it can go through the step by step execution of the generated SSL byte code, however it is abstract because it lacks the details to actually execute the SSL program in real hardware (no memory management or actual physical component controls). The abstract machine is like a byte code virtual machine, and is simple and stack based.

The compact byte code is implemented as an array of integers, w0hich is formally called the SSL Table.

The integers in the SSL table are offsets and instruction codes. The instruction codes take up the numbers 1-13 for 13 instructions:

|Integer code|Instruction|Description|
|--------------|------------|-------------|
|1|oJumpForward `label`|Jump forward to `label` (the offset is computed at compilation)|
|2|oJumpBack `label`|Jump back to `label` (the offset is computed at compilation)|
|3|oInput `token`|Consume `token` from the input stream|
|4|oInputAny|Conusme the next token (any) from the input stream|
|6|oEmit `token`|Emit `token` to the output stream|
|7|oError `signal`|Raise a `signal` error (emitting to the error stream)|
|8|oCall `label`|Call the label, used for rule calls|
|9|oReturn|Return from the label|
|10|oSetResult `value`| Sets the result (i.e. return value) to `value`|
|11|oChoice `table`|Handle a choice operation by calling the choice table (choices have their own implemented tables)|
|12|oEndChoice|End the choice operation|
|13|oSetParameter `value`| Sets the parameter for semantic operations to `value`|

Note that these instructions are mnemonics, that is, a human readable meaning assigned to these integer codes. They do not actually exist as some sort of source code, but merely help to understand the contents of the SSL table.

## The SSL Interpreter
As said before, the SSL table (the SSL bytecode) is designed to be interpreted by the SSL abstract machine. Since the machine is abstract, we simulate the machine using an SSL WALKER. This is the implementation of the SSL abstract machine is some known (that is actually executable) program langauge. Essentially, the SSL walker serves to 'fill in the gaps' to allow for actual execution of SSL byte code.

The below code shows the implementation of the SSL walker in C:

![[Pasted image 20230119165731.png]]

It first reads the SSL table into memory and then enters a while loop that breaks when the processing is finished.

Within the while loop, `SSLPointer` is used to index the SSL table to retrieve the integer at that location. This is integer is fed into a switch-case which defines the functionality for each of the 13 instructions.

This switch case also defines the functionality (i.e. the implementation) for our semantic operations.

## Instruction Memory
As said before, the SSL table is the generated byte code and therefore the instruction memory of the SSL machine. It is an array of integers which represent relevant instructions and offsets. 

Let's go through a set of sample instructions:

![[Pasted image 20230119171759.png]]

The leftmost column is the mnemonic representation of the contents of the SSL table. That is, it is the human readable interpretation of the contents of the SSL table and does NOT actually exist as some sort of source code. These serve to interpret the SSL table in a way we can easily read.

In implementation, the mnemoics can be used as identifier for the constants of the integer codes for the instructions.

The middle column represents the contents of the SSL table that map to the SSL assembly code instructions in the leftmost column. It uses the format `<index in SSL Table>:<value>`. So for example `201:3` means index 201 in the SSL table has the value 3.

Let's understand the listed instructions:

```
oJumpForward L9
```
The oJumpForward instruction has its integer code (1) stored in the SSL table at index 123. The value of `55` in index 124 is the computed offset from the current index (124) and the index that label `L9` begins at (179): 179-124 = 55

```
oJumpBack L1
```
Similarly, oJumpBack has the integer code (2) stored in index 172 of the SSL Table. In the same fashion, the next cell in the SSL table has the computed offset between the cell (173) and ethe specified label (L1 at 150) = 23.
*Note that the offset calculates from the offset cell in the SSL table rather than the instruction cell because the walker must read that location to get the offset and will therefore be at that lcocation when the jump must be performed*

```
oInput '%'
```
We have the integer code for oInput (3) in index 201 of the SSL table. This is then followed by the integer code for the specifed token/character. In this case, the token for `%` is 15.

```
oInputAny
```
In this case we only require one cell since this just instructs the SSL program to consume the next token. As standard, the integer code for the instruction (4) is stored in the appropriate index in the array.

```
oEmit foo
```
We have the integer code for oEmit (5) first stored in index 153 followed by the integer value for the variable `foo` stored in the next index.

## SSL Defined Operation Implementations
Now we will look out how the SSL table implements the different SSL program operations through the 'SSL assembly code' (the instruction mnemonics).

### Call/Return
The rule call and return are straightforward:

![[Pasted image 20230119173602.png]]

First the rule sections are converted to labels in the SSL assembly code. The rule call is converted to an oCall instruction which receives the rule name as the argument. The return is just done with the `oReturn` instruction.

### Loops
Cycles are a little more complicated. Consider the generic cycle code and its assembly code representation:

![[Pasted image 20230119173942.png]]

Again the rule label is converted to an assembly label, but then we have a few new things.

For a given loop code, two labels are generated:
- One right before the loop code begins (L25)
- One right before the code after the loop (outside of it) begins (L26)

These labels are used with jump instructions to enforce the loop repetition.
- `oJumpBack L25` is placed right after the loop code to enforce the loop repetition
- All loop exit operations are replaced with `oJumpForward L26` to enforce the loop break when it occurs

As seen above, L26 marks the code outside of the loop, which in this case is just a rule return replaced with oReturn.

### Choice Conditionals
Choice conditionals used for input and semantic choices are implemented as an array of value label pairs preceeded by the count of how many pairs are in the table:

![[Pasted image 20230119174702.png]]

The table is ended with the code for the default operation of the choice.

The value in each pairing is the choice matching condition in the SSL program source code. 
- For input choice tables (no selector so we match against the next input token), the values are the input token values used in the choice labels (in the source code) e.g. values can be `cBlank`, `cIllegal`, `oJumpForward` etc.
- For semantic choices, the values are the constant values of the type that is returned.

The SSL abstract machine searches N entries for a match, and if none is found execution continues at the end of the table (hence why the default code is located there)

If no default exists, the oEndChoice instruction is used to indicate that. If an oEndChoice is executed, an error is caused. This makes sense since a failure to match any choice label raises an error.

### Semantic Mechanisms
Semantic mechanisms are implemented by extending the SSL machine to have more operation codes.

Each semantic operation is implemented as a new operation code, which is added to the switch case (along with the code statements to implement the operation) in the SSL walker. This is done by hand.

Semantic operations can use two special "registers":
- The resultValue register holds the result of a choice rule or choice semantic operation (i.e. the return contents)
- The parameterValue register holds the parameter value given to a parametrized semantic operation.

This then tells us how choice rules and semantic operations are interpreted into the SSL assembly code:

![[Pasted image 20230119180015.png]]

The choice rule Foo returns a user defined type boolean. This translates to the assembly by using the oSetResult instruction with argument 1, to set the resultValue register, which is the integer code for the boolean type.

The oCountPush call is done by first setting the parameterValue register to the contents passed in (in this case, the actual value of the defined type constant), then the call to the semantic operation is translated directly.

## SSL Table Example Translation
With this knowledge we can understand the sample translation provided in the figure below:

![[Pasted image 20230119180333.png]]

Of course we have the skipBlanks rule label converted into the assembly label.

Since we begin with a loop, we have the assembly generated labels for the loop:
- L1 for the beginning of the loop code
- L5 for outside of the loop code

Under L1 we have the oInputChoice instruction which receives the TBL label as its argument. The TBL label defines the choice options for the choice conditional. Since this is an input choice selector, the assembly choice table is made up of the specified input token matchers:

- `cBlank L2` is for the first choice, if it is a match it will go to the L2 label. In the SSL table, index 61 contains the offset between that location and the L2 label (index 53)
- `cillegal L3` is for the second choice, and like the last generated the new label L3. Again like previous, the offset between the current pointer and L3 is calculated and placed in the byte slot following the token slot

In both cases, `cBlank` and `cIllegal` are converted to their representations and stored in the appropriate location in the SSL table (index 60 and index 62 respectively)

The labels L2 and L3 contain the assembly code for the statements of their assigned choice labels:

- L2 uses `oJumpForward` to jump to the L4 label, which just performs a jump back to the L1 label. This creates the loop case for the `cBlank` choice label.
- L3 first does the oError instruction to accont for `#eBadChar`. Index 55 contains the integer opcode for oError and index 56 contains the integer representation for eBadChar.
	- Then it jumps forward to L4 to reloop

For L5, we call the oReturn instruction to finish the rule call.

Note that this generated code is inefficient, (e.g. L4 is redundant as L1 can be used directly), but this is just the sample case.

## The SSL Processor and SSL Walker
The SSL Processor is a program that compiles SSL programs into the bytecode for the SSL abstract/virtual machine.

![[Pasted image 20230119213647.png]]

The processor takes the SSL program as input and generates two files:
- The SSL Definitions file (in PT Pascal source code)
- The SSL Table file ( Binary file of integers)

The definitions file contains the constants defined in the SSL program as PT Pascal constants. These must be merged into the source of the SSL walker for it to interpret the SSL bytecode.

The walker must also be customized with the code to implement semantic mechanisms (if any) used in the SSL program and then compiled to make a runnable walker.

The runnable walker will read the generated SSL Table File at runtime. It reads the table and the executes it operation by operation, just like we saw above.

![[Pasted image 20230119214048.png]]





